# Starknet Sequencer 交易处理流程代码解析

// ... existing code ...

## 区块的封装和批准

这个功能主要是在 sequencer 代码的批处理器(Batcher)组件中实现的。具体来说，当区块通过共识被批准后，会调用 `commit_proposal_and_block` 方法来完成区块的封装和批准。这个方法在 `crates/apollo_batcher/src/batcher.rs` 文件中：

[batcher.rs:552-626](https://github.com/starkware-libs/sequencer/blob/master/crates/apollo_batcher/src/batcher.rs#L552-L626)

```rust
async fn commit_proposal_and_block(  
    &mut self,  
    height: BlockNumber,  
    state_diff: ThinStateDiff,  
    address_to_nonce: HashMap<ContractAddress, Nonce>,  
    consumed_l1_handler_tx_hashes: IndexSet<TransactionHash>,  
    rejected_tx_hashes: HashSet<TransactionHash>,  
) -> BatcherResult<()> {  
    info!(  
        "Committing block at height {} and notifying mempool & L1 event provider of the block.",  
        height  
    );  
    trace!("Rejected transactions: {:#?}, State diff: {:#?}.", rejected_tx_hashes, state_diff);  
  
    // Commit the proposal to the storage.  
    self.storage_writer.commit_proposal(height, state_diff).map_err(|err| {  
        error!("Failed to commit proposal to storage: {}", err);  
        BatcherError::InternalError  
    })?;  
  
    // Notify the L1 provider of the new block.  
    let rejected_l1_handler_tx_hashes = rejected_tx_hashes  
        .iter()  
        .copied()  
        .filter(|tx_hash| consumed_l1_handler_tx_hashes.contains(tx_hash))  
        .collect();  
  
    let l1_provider_result = self  
        .l1_provider_client  
        .commit_block(  
            consumed_l1_handler_tx_hashes.iter().copied().collect(),  
            rejected_l1_handler_tx_hashes,  
            height,  
        )  
        .await;  
  
    // Return error if the commit to the L1 provider failed.  
    if let Err(err) = l1_provider_result {  
        match err {  
            L1ProviderClientError::L1ProviderError(L1ProviderError::UnexpectedHeight {  
                expected_height,  
                got,  
            }) => {  
                error!(  
                    "Unexpected height while committing block in L1 provider: expected={:?}, \  
                     got={:?}",  
                    expected_height, got  
                );  
            }  
            other_err => {  
                error!(  
                    "Unexpected error while committing block in L1 provider: {:?}",  
                    other_err  
                );  
            }  
        }  
        // Rollback the state diff in the storage.  
        self.storage_writer.revert_block(height);  
        return Err(BatcherError::InternalError);  
    }  
  
    // Notify the mempool of the new block.  
    let mempool_result = self  
        .mempool_client  
        .commit_block(CommitBlockArgs { address_to_nonce, rejected_tx_hashes })  
        .await;  
  
    if let Err(mempool_err) = mempool_result {  
        error!("Failed to commit block to mempool: {}", mempool_err);  
        // TODO(AlonH): Should we rollback the state diff and return an error?  
    };  
  
    STORAGE_HEIGHT.increment(1);  
    Ok(())  
}
```

这个方法是在共识达成后由 `decision_reached` 方法调用的，整个过程实际上就是区块被"sealed and approved"的实现。方法执行以下关键步骤：

- 将区块提案（proposal）和状态差异（state diff）提交到存储
- 通知 L1 提供者（L1 provider）关于新区块
- 通知内存池（mempool）关于新区块
- 递增存储高度计数器

在这个过程中，如果提交到 L1 提供者失败，它会回滚状态差异并返回错误。

`decision_reached` 方法是触发这整个过程的入口点：

[batcher.rs:501-528](https://github.com/starkware-libs/sequencer/blob/master/crates/apollo_batcher/src/batcher.rs#L501-L528)

```rust
pub async fn decision_reached(  
    &mut self,  
    input: DecisionReachedInput,  
) -> BatcherResult<DecisionReachedResponse> {  
    let height = self.active_height.ok_or(BatcherError::NoActiveHeight)?;  
  
    let proposal_id = input.proposal_id;  
    let proposal_result = self.executed_proposals.lock().await.remove(&proposal_id);  
    let block_execution_artifacts = proposal_result  
        .ok_or(BatcherError::ExecutedProposalNotFound { proposal_id })?  
        .map_err(|err| {  
            error!("Failed to get block execution artifacts: {}", err);  
            BatcherError::InternalError  
        })?;  
    let state_diff = block_execution_artifacts.thin_state_diff();  
    let n_txs = u64::try_from(block_execution_artifacts.tx_hashes().len())  
        .expect("Number of transactions should fit in u64");  
    let n_rejected_txs =  
        u64::try_from(block_execution_artifacts.execution_data.rejected_tx_hashes.len())  
            .expect("Number of rejected transactions should fit in u64");  
    self.commit_proposal_and_block(  
        height,  
        state_diff.clone(),  
        block_execution_artifacts.address_to_nonce(),  
        block_execution_artifacts.execution_data.consumed_l1_handler_tx_hashes,  
        block_execution_artifacts.execution_data.rejected_tx_hashes,  
    )  
    .await?;  
    // ...其余代码  
}
```

### Notes

这些代码展示了 Starknet Sequencer 如何封装和批准区块的过程：

- 区块的封装和批准是在共识达成后通过 `commit_proposal_and_block` 方法完成的
- 整个过程包括将区块提交到存储、通知 L1 提供者和内存池
- 如果任何步骤失败，会回滚变更以保持系统一致性