# StarkEx 验证失败处理流程

## 1. 验证失败概述

当 STARK 证明包含无效数据时，验证器会通过多层验证机制快速检测并拒绝该证明。这种设计确保了系统的安全性和效率。

## 2. 失败检测机制

### 2.1 早期检测
```solidity
function initVerifierParams(uint256[] memory publicInput, uint256[] memory proofParams)
    internal
    view
    returns (uint256[] memory ctx)
{
    // 参数有效性检查
    require(proofParams.length > PROOF_PARAMS_FRI_STEPS_OFFSET, "Invalid proofParams.");
    require(
        proofParams.length ==
            (PROOF_PARAMS_FRI_STEPS_OFFSET + proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET]),
        "Invalid proofParams."
    );
    
    // 安全参数检查
    require(proofOfWorkBits <= 50, "proofOfWorkBits must be at most 50");
    require(proofOfWorkBits >= minProofOfWorkBits, "minimum proofOfWorkBits not satisfied");
    require(proofOfWorkBits < numSecurityBits, "Proofs may not be purely based on PoW.");
}
```

### 2.2 验证失败点

1. 参数验证失败
```solidity
// 参数范围检查
require(logBlowupFactor <= 16, "logBlowupFactor must be at most 16");
require(logBlowupFactor >= 1, "logBlowupFactor must be at least 1");
```

2. 工作量证明验证失败
```solidity
function verifyProofOfWork(uint256 channelPtr, uint256 proofOfWorkBits) internal pure {
    uint256 proofOfWorkThreshold = uint256(1) << (256 - proofOfWorkBits);
    require(proofOfWorkDigest < proofOfWorkThreshold, "Proof of work check failed.");
}
```

3. FRI 验证失败
```solidity
function friVerifyLayers(uint256[] memory ctx) internal view virtual {
    require(
        friStatementContract.isValid(keccak256(abi.encodePacked(dataToHash))),
        "INVALIDATED_FRI_STATEMENT"
    );
}
```

4. Merkle 证明验证失败
```solidity
function verifyMerkle(
    uint256 channelPtr,
    uint256 queuePtr,
    bytes32 root,
    uint256 n
) internal view virtual override returns (bytes32) {
    require(merkleStatementContract.isValid(statement), "INVALIDATED_MERKLE_STATEMENT");
}
```

## 3. 失败处理流程

### 3.1 验证流程中断
当检测到无效数据时，验证器会立即停止验证过程：
1. 抛出异常
2. 回滚所有状态更改
3. 拒绝整个证明和状态差异

### 3.2 错误传播
```solidity
function verifyProof(
    uint256[] memory proofParams,
    uint256[] memory proof,
    uint256[] memory publicInput
) internal view override {
    // 初始化验证参数
    uint256[] memory ctx = initVerifierParams(publicInput, proofParams);
    
    // 如果任何验证步骤失败，整个验证过程将立即终止
    ctx[MM_TRACE_COMMITMENT] = uint256(readHash(channelPtr, true));
    oodsConsistencyCheck(ctx);
    computeFirstFriLayer(ctx);
    friVerifyLayers(ctx);
}
```

### 3.3 状态回滚
1. 所有中间状态被丢弃
2. 合约状态恢复到验证开始前
3. 交易被标记为失败

## 4. 安全影响

### 4.1 数据污染防护
- 单个无效数据会导致整个证明被拒绝
- 防止部分有效数据被接受
- 确保数据完整性

### 4.2 攻击防护
- 防止无效证明被接受
- 防止状态被错误更新
- 保护系统安全

## 5. 错误处理最佳实践

### 5.1 错误信息
```solidity
// 清晰的错误信息
require(proofParams.length > PROOF_PARAMS_FRI_STEPS_OFFSET, "Invalid proofParams.");
require(proofOfWorkBits >= minProofOfWorkBits, "minimum proofOfWorkBits not satisfied");
require(merkleStatementContract.isValid(statement), "INVALIDATED_MERKLE_STATEMENT");
```

### 5.2 资源管理
- 早期失败检测
- 及时释放资源
- 避免不必要的计算

### 5.3 日志记录
```solidity
event LogBool(bool val);
event LogDebug(uint256 val);
```

## 6. 总结

StarkEx 的验证失败处理机制确保了：
1. 快速失败：一旦检测到无效数据，立即停止验证
2. 完全回滚：所有状态更改被撤销
3. 安全保证：防止任何无效数据被接受
4. 资源效率：避免在无效证明上浪费计算资源

这种严格的处理机制是系统安全性的重要保障，确保了只有完全有效的证明才能被接受。
